---
title: 数据结构
date: 2017-11-11 19:07:18
tags: 数据结构
mathjax: true
---

### 引子

诚者自成也，而道自道也。

诚者，物之终始。不诚无物。是故君子诚之为贵。

诚者，非自成己而己也。所以成物也。成己仁也，成物知也。性之德也，合外内之道也。故时措之宜也。

--《中庸》

### 绪论

*数据结构*

- 数据(data): 是对客观事物的符号表示。在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的      总称。
- 数据元素(data element)：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理
- 数据对象(data object)：是性质相同的数据元素的集合，是数据的一个子集。
- 数据结构(data structure)：又称逻辑结构，是相互之间存在一种或多种特定关系的数据的集合，通常包括四种：集   合、线性结构、树形结构、网状结构。
- 存储结构：是数据结构在计算机中的表示。
- 数据类型(data type)：是一个值的集合和定义在这个值集上的一系列操作的总称。
- 抽象数据类型(AbstractData Type)：是指一个数据模型以及定义在该模型上的一组操作，可细分为：原子类型、固定聚合类型、可变聚合类型。

*算法*

算法的5个重要特性：有穷性，确定性，可行性，输入，输出

衡量一个算法是否优秀，一般从以下几个点考虑：正确性，可读性，健壮性，时间复杂度，空间复杂度

一般情况下，算法中基本操作重复执行的次数时问题规模n的某个函数f(n)，算法的时间量度记作：T(n) = O(f(n))。他表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。

类似时间复杂度，基本操作带来的空间消耗和问题规模n通常也有关系，这个关系叫空间复杂度：S(n) = O(f(n))。若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的额外空间，否则应该同时考虑输入本身所需空间。若额外空间相对于输入数据量来说是常数，则称此算法为原地工作。

算法书写规范
- 算法说明：指明算法功能；参数表中各参量的含义和输入输出属性；算法中引入了哪些全局变量或外部定义的变量，作用入口初值以及应满足哪些限制条件
- 注释和断言：注释抽象度应高于语句，断言用来陈述算法执行到此处应该满足的条件
- 输入和输出：scanf和printf语句；参数显示；全局变量或外部变量隐式的传递信息
- 错误处理：尽可能使用函数返回算法的执行状态，便于调用者处理异常情况，有益于培养良好的程序设计习惯
- 语句选用和算法结构：尽量不使用goto
- 基本运算：自己实现
- 建议：使用图说明算法；用边界条件检测算法

### 第二章

线性表和单链表

### 第三章

*栈和队列*

表达式求值：算符优先法

为了实现算符优先法，可以使用两个工作栈，一个称作OPTR，用来寄存运算符，另一个称为OPND用来寄存操作数或运算结果。

1. 首先置操作数栈为空栈，表达式起止符‘#’为栈底元素
2. 依次读入表达式中的每个字符，若是操作数则进OPND栈，若是运算符则和OPTR栈的栈顶运算符比较优先权后作相应操作，直至整个表达式求值完毕（即OPTR的栈顶元素和当前读入字符均为‘#’）

*栈与递归的实现*

递归：一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。

[hanoi问题](https://baike.baidu.com/item/%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98/1945186?fr=aladdin)：
```c
#include <stdio.h>
int c = 0;
void moveH(char *x, int n, char *z){
    printf("%i. Move disk %i from %s to %s\n", ++c, n, x, z);
}
void hanoi(int n, char *x, char *y, char *z){
    // 将塔座x上按直径由小到大且自上而下编号为1到n的n个圆盘按规则搬到塔座z上，y可以作为辅助塔座。(c是初值为0的全局变量，对搬动记数)
    // 搬动操作move(x,n,z)可定义为: printf("%i. Move disk %i from %c to %c\n", ++c, n, x, z);
    if(n == 1){
        moveH(x, 1, z);
    } else {
        hanoi(n-1, x, z, y);
        moveH(x, n, z);
        hanoi(n-1, y, x, z);
    }
}
int main()
{
    char first[20] = "第一个柱子";
    char second[20] = "第二个柱子";
    char third[20] = "第三个柱子";
    
    hanoi(10, first, second, third);
    return 0;
}
```

递归的实现：调用函数和被调用函之间的链接及信息交换需要通过栈来执行

在运行被调用函数之前，系统需要先完成3件事

1. 将所有的实参、返回地址等信息传递给被调用函数保存
2. 为被调用函数的局部变量分配存储区
3. 将控制转移到被调用函数的入口

从被调用函数返回调用函数之前，系统也要完成三件工作

1. 保存被调用函数的计算结果
2. 释放被调用函数的数据区
3. 依照被调用函数保存的返回地址将控制转移到调用函数

*队列*

循环队列

*离散事件模拟*

略

### 第四章 串

*kmp算法（克努特-莫里斯-普拉特算法）*

思路：模式串本身是已知量，已知量，若和待匹配字符串已经出现部分匹配，则根据这部分匹配我们可以得知，再进行匹配需要滑动的距离。根本目的在于减少重复计算量

关键：next函数
```
// j是模式串的下标，k是滑动距离
next[j] = k
```
> tips: 求next函数的过程其实也是一个递归的过程，哈哈哈哈，考虑相同字符问题可以对算法进行修正，得到更好的答案。此算法启示为对细节孜孜不倦的苛求，可以有颠覆的结论。

### 第五章 数组和广义表

*矩阵的压缩存储*

压缩存储是指：为多个值相同的元只分配一个存储空间，对零元不分配空间

[矩阵](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5/18069?fr=aladdin)运算: 加法，减法，数乘，转置，共轭，共轭转置，乘法，行列式

对称矩阵，三角矩阵，对角矩阵

稀疏矩阵：三元组存储法(位置，值)

*广义表*

广义表一般记作：LS = $(a_1,a_2,...,a_n)$

$a_i$可以是单个元素，也可以是子表，分别称为`原子`和`子表`。习惯上用大写字母表示广义表的名称，用小写字母表示广义表的原子，表非空时，习惯称第一个元素为`表头`，其余元素组成的表为`表尾`

*广义表的存储结构*

通常采用链式存储。

*m元多项式的表示*

1. $P(x,y,x) = x^{10}y^3z^2 + 2x^6y^3z^2 + 3x^5y^2z^2 + x^4y^4z + 6x^3y^4z + 2yz + 15$
2. $P(x,y,x) = ((x^10+2x^6)y^3 + 3x^5y^2)z^2 + ((x^4+6x^3)y^4 + 2y)z + 15$
3. 广义表表示：$P = z((A,2),(B,1),(15,0))$ (数字代表变元的幂次)
4. 其中$A = y((C, 3), (D, 2)) C = x((1, 10), (2, 6)) D = x((3, 5)) B = y((E, 4), (F, 1)) E = x((1, 4), (6, 3)) F = x(2, 0)$

*广义表的递归算法*

分治法设计递归算法

1. 首先应书写函数的首部和规格说明，严格定义函数的功能和接口（递归调用的界面），对求精函数中所得的和原问题性质相同的子问题，只要接口一致，便可进行递归调用
2. 对函数中的每一个递归调用都看成只是一个简单的操作，只要接口一致，必能实现规格说明中定义的功能，切忌想的太深太远。

> 重要的是递归思想的理解和运用

### 树和二叉树

树的定义：树(Tree)是n(n>=0)个结点的有限集，在任何一个非空树中，树特征：
- 有且只有一个特定的称为根(Root)的结点
- 当n>1时，其余结点可分为m(m>0)个互不相交的有限集$T_1,T_2...,T_m$，其中每一个集合本身又是一棵树，并且称为根的`子树(subtree)`

树的`结点`包含一个数据元素及若干指向其子树的分支。结点拥有的子树数称为`结点的度`(Degree)。度为0的结点称为`非终端结点`或`分支结点`。除根节点之外，分支结点也称为内部结点。`树的度`是树内各结点的度的最大值。结点的子树的根的根称为该结点的孩子(Child)，相应地，该结点称为孩子的双亲(Parent)。同一个双亲的孩子之间互称为`兄弟`。结点的`祖先`是从根到该节点所经分支上的所有结点。以某结点为根的子树中的任一节点都称为该节点的`子孙`。

结点的`层次`从根开始定义，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为`堂兄弟`。树中结点的最大层次称为树的`深度`(Depth)或高度。

如果树的结点的各子树看成从左至右是有次序的（即不能互换），则称该树为`有序树`，否则称为`无序树`。在有序树中，最左边子树的根称为第一个孩子，最右边的称为最后一个孩子。

`森林(Forest)`是m(m>0)棵互不相交的树的集合。对树中的每个结点而言，其子树的集合即为森林。由此，也可以森林和树相互递归的定义来描述树。

Tree = (root, F);$F=(T_1,T_2,...,T_m);T_i=(r_i, F_i)$

*二叉树*

二叉树是另一种树形结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分，其次序不能任意颠倒。

二叉树有五种形态：空二叉树，仅有根节点的二叉树，右子树为空的二叉树，左右子树均非空的二叉树，左子树为空的二叉树

二叉树的性质：
1. 在二叉树第i层上至多有$2^{i-1}$个结点
2. 深度为k的二叉树至多有$2^k-1$个结点
3. 对任何一个二叉树，如果其终端结点数为$n\_0$，度为2的结点数为$n\_2$。则$n\_0 = n\_2+1$。思路：节点总数为$n = n\_0 + n\_1 + n\_2$；根据分支推出等式：$ n - 1 = B = n\_1 + 2n\_2$；结合两个等式即可推出。一颗深度为k且有$2^k-1$个结点得二叉树称为`满二叉树`。深度为k的，有n个结点的二叉树，当且仅当其每一点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称之为`完全二叉树`。
4. 具有n个结点的完全二叉树的深度为$\lfloor log_2n\rfloor + 1$
5. 对于一颗有n个结点的完全二叉树的结点按层序编号，则对任一结点i，有：
    - i=1，此结点为根节点；i>1，则其双亲PARENT(i)是结点$\lfloor i/2 \rfloor$
    - 如果2i>n,则结点i无左孩子；否则其左孩子LCHIL(i)是结点2i
    - 如果2i+1>n，则结点i无右孩子；否则其右孩子RCHILD(i)是结点2i+1
二叉树的存储结构

顺序存储：最坏的情况，一个深度为k且有k个结点的二叉树却需要长度为$2^k-1$的一维数组

链式存储：二叉链表和三叉链表

遍历二叉树和线索二叉树

特点：先序中序后序是根据根结点的位置定的，顺序是先左后右

1. 先序遍历二叉树操作定义(DLR):
    1. 访问根结点
    2. 先序遍历左子树
    3. 先序遍历右子树
2. 中序遍历二叉树的操作定义(LDR):
    1. 中序遍历左子树
    2. 访问根结点
    3. 中序遍历右子树
3. 后序遍历二叉树的操作定义(LRD):
    1. 后序遍历左子树
    2. 后序遍历右子树
    3. 访问根结点

从中序遍历递归算法执行过程中递归工作栈的状态可见：
1. 工作记录中包含两项，其一是递归调用的语句编号，其二是指向根结点的指针，则当栈顶记录中的指针非空时，应遍历左子树，即指向左子树根的结点入栈。
2. 若栈顶记录种的指针值为空，则应退至上一层，若是从左子树返回，则应访问当前层即栈顶记录中指针所指的根结点。
3. 若是从右子树返回则表明当前层的遍历技术，应继续退栈。从另一角度看，这意味着，遍历右子树时不再需要保存当前层的根指针，可直接修改栈顶记录中的指针即可。

“遍历”是二叉树各种操作的基础，可以在遍历过程中对结点进行各种操作，如：对于一棵已知树可求结点的双亲，求结点的孩子结点，判定结点所在层次，反之，也可在遍历的过程中生成结点，建立二叉树的存储结构。

对二叉树进行遍历的搜索路径除了上述先序、中序、后序外，还可以从上到下、从左到右按层次进行。

显然，遍历二叉树的算法中的基本操作是访问结点，则不论按哪一种次序进行遍历，对含n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n，则空间复杂度也为O(n)。遍历的时候也可以采用二叉树的其他存储结构，如带标志域的三叉链表，此时因存储结构中已存有遍历所需足够信息，则遍历过程中不需另设栈。

*线索二叉树*

如下规定：若结点有左子树，则其lchild域指示其左孩子，否则令lchild域指示其前驱；若结点有右子树，则其rchild域指示其右孩子，否则令rchild域指示其后继。为了避免混淆，还需要改变结点结构，增加两个标志域：lchild,LTag,data,RTag,rchild。其中LTag取值0，1，分别代表lchild域指示左孩子，前驱。RTag同理。

以这种节点结构构成的二叉链表作为二叉树的存储结构，叫做`线索链表`，其中指向结点前驱和后继的指针，叫做`线索`。加上线索的二叉树称之为`线索二叉树`。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做`线索化`。

*树和森林*

树得存储结构

双亲表示法：一组连续空间存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在链表中的位置。

孩子表示法：把每个结点的孩子结点排列起来，看成一个线性表，且以单链表作为存储结构，则n个结点有n个孩子链表。而n个头指针又组成一个线性表

孩子兄弟表示法：又称二叉树表示法，或二叉链表示法。即以二叉链表作树的存储结构。链表中结点的两个链域分别指向该节点的第一个孩子结点和下一个兄弟结点。（按照这个思想，所有的树都可以转换为二叉树！！）

*森林与二叉树的转换*

从树的二叉链表示法可知，任何一课和树对应的二叉树，其右子树必然为空，若把森林中下一棵树看成前一棵树的根结点二叉树表示的右儿子，则同样可以导出二叉树和森林的对应关系

*树和森林的遍历*

同样分为：先序遍历，中序遍历，后序遍历

*树与等价关系*

概念：等价关系，等价类，利用树可以划分等价类

#### 赫夫曼树及其应用

从树中一个结点到另一个结点的分支构成这两者之间的路径，路径上的分支数目称为`路径长度`。`树的路径长度`是从树根到每一个结点的路径长度之和。`树的带权路径长度`为树中所有叶子结点的带权路径长度之和，通常记作: $WPL = \sum_{k=1}^{n}w\_kl_k$

假设有n个权值${w\_1,w\_2,...,w\_n}$，试构造有n个叶子结点的二叉树，每个叶子结点带权值为$w_i$，其中带权路径长度WPL最小的二叉树称作`最优二叉树`或`赫夫曼树`

*赫夫曼算法*

1. 根据给定的n个权值${w\_1,w\_2,...,w\_n}$构成n棵二叉树的集合$F={T\_1,T\_2,...,T\_n}$，其中每一棵二叉树$T\_i$中只有一个带权为$W\_i$的根结点，其左右子树均空
2. 在F中选取两棵根结点的权值最小的树作为左右子树构造一颗新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
3. 在F中删除这两棵树，同时将新得到的二叉树加入到F中
4. 重复2，3步骤，直到F中只含有一颗树为止。这棵树便是赫夫曼树

*赫夫曼编码*

若要设计长短不等的编码，则必须是任一个字符的编码都不是另一个字符的编码的前缀，这种编码称做`前缀编码`

![赫夫曼编码][hfm]

假设每种字符在电文中出现的次数为$w\_i$，其编码长度为$l\_i$，电文中只有n种字符，则电文总长为$\sum\_{i=1}^{n}w\_il\_i$。对应到二叉树上，若置$w\_i$为叶子结点的权，$l\_i$恰为从根到叶子的路径长度。则$\sum\_{i=1}^{n}w\_il\_i$恰为二叉树上的带全路径长度。由此可见，设计电文最短的二进制前缀编码即以n种字符出现的频率作权，设计一棵赫夫曼树的问题，由此得到的二进制前缀编码称为赫夫曼编码。

*回溯法与树的遍历*

在程序设计中，有相当一类求一组解、或求全部解或求最优解的问题，例如：[八皇后问题](https://baike.baidu.com/item/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/11053477?fr=aladdin)。不是根据某种确定的计算法则，而是利用试探和`回溯`得搜索技术求解。回溯法也是递归设计的一种重要的方法，它的求解实质上是一个先序遍历一棵‘状态树’的过程，只是这棵树不是遍历前预先建立的，而是隐含在遍历过程中，但如果认识到这点，很多问题的递归过程也就迎刃而解了。

题目：求含n个元素的集合的幂集。
集合A的幂集是由集合A的所有的子集所组成的集合。则A得幂集为$\rho(A)$。

可以利用分治法来设计解法，在此，从另一角度分析问题。幂集的每个元素是一个集合，它或是空集，或含集合A中的一个元素，或集合A中的两个元素，或等于集合A。反之，从集合A的每个元素看，它只有两种状态：它或属于幂集的元素集，或不属于A的幂集元素集。则求$\rho(A)$的元素的过程可看成是依次对集合A中元素进行取或舍的过程，并且可以用一棵树来表示。

![回溯法][hsf]

算法：
```c
void PowerSet(int i, int n){
    //求含n个元素的集合A的幂集$\rho(A)$。进入函数时已对A中前i-1个元素做了取舍处理，现从第i个元素起进行取舍处理。若i>n则求得幂集的一个元素并输出之，初始调用：PowerSet(1, n)
    if(i > n) 输出幂集的一个元素；
    else {
        取第i个元素: PowerSet(i+1, n);
        舍第i个元素: PowerSet(i+1, n);
    }
} // PowerSet
```
上述问题的解决是一个满二叉树，树中每个叶子结点的状态都是求解过程中可能出现的状态(即问题的解)。然而很多问题用回溯法和试探求解的时候，描述求解过程的状态树不是一棵满的多叉树。当时谈过程中出现的状态和问题求解产生矛盾时，不再继续试探下去。这时出现得叶子结点不是问题的解的终结状态。这类问题的求解过程可看成是在约束条件下进行先序遍历，并在遍历过程中剪去那些不满足条件的分支。

*树的技术*

推导过程较麻烦，略，有用到再说

揭露：n个结点的不想似的二叉树有$\frac{1}{n+1}C^n_{2n}$


### 图

图是一种数据结构，加上一组基本操作，就构成了抽象数据类型。在图形结构中，结点之间的关系可以是任意的，图中任意两个元素之间都有可能相关。

在图中的数据元素通常称为`顶点`(Vertex)，V是顶点的有穷非空集合；VR是两个顶点之间的关系的集合。若$<\nu,\omega>\in VR$，则$<\nu,\omega>$表示从$\nu$到$\omega$的一条`弧`(Arc)。且称$\nu$为`弧尾`或初始点(Initial node)，称$\omega$为弧头(HEAD)或终端点(Terminal node)，此时的图称为`有向图`(Digraph)。若$<\nu,\omega>\in VR$，则必有$<\omega,\nu>\in VR$。即VR是对称的，则以无序对$(\nu,\omega)$代替这两个有序对，表示$\nu$和$\omega$的一条`边`(Edge)，此时的图称为`无向图`(Undigraph)。

我们用n表示图中顶点的数目，用e表示边或弧的数目。在下面的讨论中，我们不考虑顶点到其自身的弧或边，即若$<\nu\_i, \nu\_j> \in VR$则$i \not= j$，那么，对于无向图，e的取值范围是0到$\frac{1}{2}n(n-1)$。有$\frac{1}{2}n(n-1)$条边的无向图称为`完全图`(Completed graph)。对于有向图e的取值范围是0到$n(n-1)$。具有$n(n-1)$条弧的有向图称为有向完全图。又很少条边或弧(如$e < nlogn$)的图称为`稀疏图`(Sparse grapth)。反之称为`稠密图`(Dense grapth)。

有时图的边或弧具有与它相关的数，这种与图的边或弧相关的数叫做`权`(Weight)。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为`网`(Network)。

假设有两个图G = (V, \{E\})和G' = (V', \{E'\})，如果$V'\subseteq V$且$E'\subseteq E$，则称G'为G的子图(Subgraph)。

对于无向图G = (V, \{E\})，如果边$(v, v') \in E$，则称v,v'互为邻接点(Ajacent)。即v和v'相邻接。边(v,v')`依附`(Incident)于定点v和v'，或者说(v,v')和定点v和v'`相关联`。顶点v的`度`(Degree)是和v相关联的边的数目。记为TD(V)。以顶点v为头的弧的数目称为`入度`(InDegree)，记为ID(V)。以v为尾的弧的数目称为v的`出度`(Outdegree)，记为OD(v);顶点v的度为TD(v) = ID(v) + OD(v);

无向图G = (V, \{E\})中从顶点$\nu$到$\nu'$的`路径`(Path)。如果G是有向图，则路径也是有向的，顶点序列应该满足$< \nu\_{i-1}, \nu\_i > \in E$。路径的长度是路径上的边或弧的数目。第一个顶点和最后一个顶点相同的路径称为`回路`或`环`。序列中顶点不重复出现的路径称为`简单路径`。除了第一个顶点和最后一个顶点，其余顶点不重复出现的回路，称为简单回路或简单环。

在无向图G中，如果从定点v到v'有路径，则称v和v'是`连通`的。如果对于图中任意两个顶点都是连通的，则称G为`连通图`(Connected Graph)。`连通分量`(Connected component)，指的是无向图中的极大连通子图。

在有向图中，如果对于每一对顶点，相互之间都存在路径，则称G是`强连通图`。有向图的极大连通子图称为有向图的`强连通分量`。

一个连通图的`生成树`是一个极小连通子图。

如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。一个有向图的`生成森林`由若干棵有向树组成，含有图中全部定点，但只有足以构成若干棵不相交的有向树的弧。

可对某个顶点的所有邻接点进行排队，在这个排队中自然形成了第一个或第k哥邻接点。若某个顶点的邻接点的排序大于k，则称第k+1个邻接点为第k个邻接点的下一个邻接点，而最后一个邻接点的下一个邻接点为'空'。

*图的存储结构*

自然采取多重链表的存储结构。由于途中各顶点度不同，最大度数和最小度数可能相差很多，因此，若按度数最大的定点设计结点结构，则会浪费很多单元；反之，按每个顶点自己的度数设计不通的结点结构，又会给操作带来不便。因此，和树类似，在实际应用中不宜采用这种结构，而应根据具体的图和需要进行的操作，设计恰当的结点结构和表结构。常用的有邻接表，邻接多重表和十字链表。

邻接矩阵表示法：使用矩阵存储顶点间相互关系，n个结点构成n*n矩阵。优点：直观，清晰。缺点：占用存储空间大

`邻接表`: 思路是每个顶点建立一个单链表，存储其邻接边信息。这样若无向图中有n个结点、e条边，则它的邻接表需n个头结点和2e个表结点。显然在边稀疏的情况下，用邻接表表示图比邻接矩阵节省存储空间。当和边相关的信息多时更是如此。邻接表判定两个顶点是否有边或弧链接，没有邻接矩阵方便

`十字链表`: 弧结点：tailvex | headvex | hlink | tlink | info 顶点结点：data | firstin | firstout。类似邻接表，但更容易找到以顶点为头或尾的弧。在某些有向图中很有用。

`邻接多重表`：和十字链表类似。无向图的另一种链式存储结构。边结点：mark | ivex | ilink | jvex | jlink | info 。顶点结点：data | firstedge

*图的遍历*

和树的遍历类似，在此，我们希望从图中的某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。这一过程叫做**图的遍历**。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。

通常有两种遍历图的路径：深度优先搜索和广度优先搜索。

`深度优先搜索`: 此遍历类似于树的先根遍历，是树的先根遍历的推广。深度优先搜索可从图中某个顶点v出发，访问此顶点，然后依次从v的未被访问的邻接点出发深度优先遍历图。

深度优先搜索，邻接矩阵的时间复杂度为$O(n^2)$，邻接表的时间复杂度为O(n+e)。

`广度优先搜索`: 类似于树的按层遍历的过程。假设从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问，直至图中所有已被访问的顶点的邻接点都被访问到。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直到所有顶点被访问到为止。

*图的连通性*

连通图：从图中任意顶点进行深度优先或广度有限访问，都能访问到所有的顶点

深度优先搜索过程生成的树为深度优先生成树；广度优先搜索过程生成的数为广度优先生成树

非连通图，对应深度优先生成森林，广度优先生成森林

`强连通分量`: 有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi>vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。

`最小生成树`: 假设要在n个城市之间建立通信联络网，则n个城市只需要n-1条线路。如何在最节省经费的前提下建立这个通信网。可以用连通网来表示这个问题，我们需要寻找到一棵耗费最小的生成树，这个问题就是`最小生成树`问题

`MST`性质：假设 N = (V, {E})是一个连通网，U是顶点集V的一个非空子集。若(u,v)是一条具有最小权值（代价）的边，其中$u \in U,v \in V - U$则必存在一棵包含边$(u, v)$的最小生成树

`普里姆算法`：假设 N = (V, {E})是一个连通网，TE是N上最小生成树中边的集合。算法从U = { $\mu_0$ }$(\mu\_0 \in V)$，TE = {} 开始，重复执行下述操作：在所有$u \in U, v \in V - U$的边$(u,v) \in E$中找一条代价最小的边$(u\_0, v\_0)$并入集合TE，同时$v\_0$并入U，直至U = V为止。此时TE中必有n-1条边，则T = (V, {TE})为N的最小生成树。

普里姆算法时间复杂度为$O(n^2)$(其中n为顶点数)。所以普里姆算法适合求边稠密的网的最小生成树

`克鲁斯卡尔算法`：假设连通网N = (V, {E})，则令最小生成树的初始状态为只有n个顶点而无边的非联通图T = (V, {})，图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到T当中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。时间复杂度为$O(eloge)$(e为边数)，因此适合求边稀疏的网的最小生成树

`关节点`：假若在删去顶点v以及和v相关联的各边之后，将图的一个连通分量分割成两个或两个以上的连通分量，则称顶点v为该图的一个`关节点`(articulation point)。

一个没有`关节点`的连通图称为`重连通图`(biconnected graph)。若连通图中至少删去k个顶点才能破坏图的连通性，则称此图的连通度为k。

一个无环的有向图称为`有向无环图`(directed acycline graph)，简称DAG图。

有向无环图是描述含有公共子式的表达式的有效工具。例如下述表达式：((a+b)\*(b\*(c+d))+(c+d)\*e)\*((c+d)\*e)

![有向无环图应用示例][dag]

有向无环图也是描述一项工程或系统的进行过程的有效工具。除最简单的情况之外，几乎所有的工程都可分为若干个称作`活动`的子工程，而这些子工程之间，通常受着一定条件的约束，如其中某些子工程的开始必须在另一些子工程完成之后。对于整个工程和系统，人们关心的是两个方面的问题：一是工程能否顺利进行；二是估算整个工程完成所必需的最短时间。

`自反关系`：设 R是 A上的一个二元关系，若对于 A中的每一个元素 a， (a,a)都属于 R，则称 R为自反关系。换言之，在自反关系中， A中每一个元素与其自身相关

`反对称关系`：反对称性是一个关于数学上二元关系的性质。大概地说，集合 X 上的二元关系 R 是反对称的，当且仅当不存在X里的一对相异元素a, b，它们 R-关系于彼此。

`传递关系`：在逻辑学和数学中，若对所有的 a，b，c 属于 X，下述语句保持有效，则集合 X 上的二元关系 R 是传递的：「若a 关系到 b 且 b 关系到 c， 则 a 关系到 c。」

`偏序`和`全序`

偏序和全序是公里集合论中的概念。

首先你要知道什么是二元关系。
比如实数中的“大小”关系，集合的集合中的“包含”关系就是两种二元关系。

所谓偏序，即偏序关系，是一种二元关系。
所谓全序，即全序关系，自然也是一种二元关系。

全序是指，集合中的任两个元素之间都可以比较的关系。比如实数中的任两个数都可以比较大小，那么“大小”就是实数集的一个全序关系。

偏序是指，集合中只有部分元素之间可以比较的关系。比如复数集中并不是所有的数都可以比较大小，那么“大小”就是复数集的一个偏序关系。

显然，全序关系必是偏序关系。反之不成立。

拓扑排序：由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。

这种用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网(Activity On Vertex Network)。简称AOV-网

*拓扑排序*

1. 在有向图中选一个没有前驱的顶点且输出之
2. 从图中删除该顶点和所有以它为尾的弧

重复上述两步，直至全部顶点均已输出，或者当前图中不存在无前驱的顶点为止，后一种情况说明有向图中存在环

*关键路径*

与AOV-网相对应的是AOE-网(Activity On Edge)即表示活动的网。AOE-网是一个带权的有向无环图，其中顶点表示事件(Event)，弧表示活动，权表示活动持续时间。

AOE-网有待研究的问题是：1，完成整项工程至少需要多少时间。2，哪些活动是影响工程进度的关键

由于在AOE-网中有些活动可以并行的进行，所以完成工程的最短时间是从开始点到完成点的最长路径的长度。路径长度最长的路径叫做`关键路径`(Critical Path)。

关键路径的算法：
1. 输入e条弧<j,k>。建立AOE-网的存储结构
2. 从源点$v_0$出发，令ve[0] = 0，按拓扑有序求其余各顶点的最早发生时间$ ve[i] (1 \le i \le (n-1)) $。如果得到的拓扑有序中顶点个数小于网中顶点数n，则说明网中存在环，不能求关键路径，算法终止；否则执行步骤3
3. 从汇点$v_n$出发，令vl[n-1] = ve[n-1]，按逆拓扑有序求其余各顶点的最迟发生时间$vl[i](n-2 \ge i \ge 2)$。
4. 根据各点的ve和vl值，求每条弧s的最早开始时间e(s)和最迟开始时间ls(s)。若某条弧满足条件e(s)=l(s)，则为关键活动。

>理解要点，求关键活动 --> 各事件最早发生时间和最迟发生时间 --> 求弧的最早发生时间和最迟发生时间 --> 关键弧。2，3步骤一个给出初始值，一个给出终值。但思路都是由后往前推，递归思想。

应用：1956年，美国杜邦公司提出关键路径法，并于1957年首先用于1000万美元化工厂建设，工期比原计划缩短了4个月。杜邦公司在采用关键路径法的一年中，节省了100万美元。

*最短路径*

假如，一个旅客从A城到B城，他希望选择一条途中中转次数最少的路线。假设图中每一站都要换车，则这个问题反映到图上就是要找一条从顶点A到B所含边的数目最少的路径。我们只需从A出发对图作广度优先搜索，一旦遇到顶点B就终止。由此所得广度优先生成树上，从根顶点A到顶点B的路径就是中转次数最少的路径，路径A与B之间的顶点就是途径的中转站数。

本节将讨论带权有向图，并称路径上的第一个顶点为`源点`(Sourse)，最后一个顶点为`终点`(Destination)。

从某个源点到其余各顶点的最短路径

`迪杰斯特拉`算法

首先，引进一个辅助向量D，它的每个分量D[i]表示当前所找到的从始点v到每个终点$v\_i$的最短路径的长度。他的初态为：若从v到$v\_i$有弧，则D[i]为弧上的权值；否则置D[i]为$\infty$。显然，长度为$D[j] = Min{D[i] | v\_i \in V}$的路径就是从v出发的长度最短的一条，此路径为$(v, v\_j)$

一般情况下，假设S为已求得最短路径的终点的集合，则可证明：下一条最短路径(设其终点为x)或者是弧(v,x)，或者是中间只经过S中的顶点而最后到达顶点x的路径。

因此在一般情况下，下一条长度次短的最短路径的长度必是：$D[j] = Min{D[i] | v_i /in V - S}$。其中，D[i]或者是弧$(v,v\_i)$上的权值或者是$D[k](v_k \in S)$和弧$(v\_k, v\_i)$上的权值之和。

根据以上分析，可得到如下描述的算法：
1. 假设用带权的邻接矩阵arcs来表示带权有向图，arcs[i][j]表示弧$(v\_i,v\_j)$上的权值。若$(v\_i,v\_j)$不存在，则置arcs[i][j]为$\infty$。S为已找到从v出发的最短路径的终点的集合，它的初始状态为空集。那么，从v出发到图上其余各顶点$v_i$可能达到的最短路径长度的初值为：$D[i] = arcs[Locate Vex(G, v)][i] v\_i \in V$。
2. 选择$v_j$，使得：$D[j] = Min{D[i] | v\_i \in V-S }$。$v\_j$就是当前求得的一条从v出发的最短路径的终点，令：$S = S \cup {j}$
3. 修改从v出发到集合V-S上任一顶点$v_k$可达的最短路径长度。如果：D[j] + arcs[j][k] < D[k]。则修改D[k]为D[k] = D[j] + arcs[j][k]
4. 重复2，3共n-1次。由此求得从v到图上其余各顶点的最短路径是依路径长度递增的序列。

迪杰斯特拉算法时间复杂度$O(n^2)$

*每一对顶点之间的最短路径*

很简单的方法是每次以一个顶点为源点，重复执行迪杰斯特拉算法n次，这样便可求的每一对顶点之间的最短路径。时间复杂度为$O(n^3)$。

弗洛伊德算法：时间复杂度也是$O(n^3)$，形式上要简单一点。

弗洛伊德算法仍然从带权的邻接矩阵cost出发，其基本思想为：

现在定义一个n阶方阵序列
$D^{-1},D^{0},D^{1},...,D^{k},...,D^{(n-1)}$

其中
$D^{-1}[i][j] = G.arcs[i][j]$
$D^{(k)}[i][j] = Min\\{D^{(k-1)}[i][j],D^{(k-1)}[i][k] + D^{(k-1)}[k][i]\\}  0 \le k \le n-1$ 

>理解要点：递归思想，根据公式理解

### 动态存储管理

动态存储管理的基本问题是系统如何应用户提出的‘请求’分配内存？又如何回收那些用户不再使用而‘释放’的内存，以备新的‘请求’产生时重新进行分配？

系统每次分配给用户都是一个地址连续的内存区。为了叙述方便起见，将统称已分配给用户使用的地址连续的内存区为‘占用快’，称未分配的地址连续的内存区为‘可利用空间块’或‘空闲块’。

当系统运行了一段时间后，内存区形成犬牙交错的形态，当有新的用户进入系统请求分配内存，那么系统应该如何做呢？

通常有两种做法：一种策略是系统继续从高地址的空闲块中进行分配，而不理会已分配给用户的内存区是否空闲，直到分配无法进行（即剩余的空间块不能满足分配的请求）时，系统才去回收所有用户不再使用的空闲块，并且重新组织内存，将所有空闲区连接在一起称为一个大的空闲块。另一种策略是用户一旦运行结束，便将它所占用的内存区释放为空闲块，同时，每当新的用户请求分配内存时，系统需要巡视整个内存区中所有空闲块，并从中找出一个‘合适’的空闲块分配之。由此，系统需建立一张记录所有空闲块的‘可利用空间表’，此表的结构可以是‘目录表’，也可以是‘链表’

*可利用空间表及分配方法*

下面仅讨论链表的情况

可以用空间表又称‘存储池’

根据系统的不同情况，可利用空间表可以有以下3种不同的结构形式：
1. 系统运行期间所有用户请求分配的存储量大小相同。对此类系统，通常的做法是，在系统开始运行时将归它使用的内存区按所需大小分割成大小相同的块，然后用指针链接成一个可利用空间表。由于表中结点大小相同，则分配时无需查找，只要将第一个结点分配给用户即可；同样，当用户释放内存时，系统只要将用户释放的空间块插入在表头即可。可见，这种情况下的可利用空间表实质上是一个链栈。这是一种最简单的动态存储管理方式。
2. 系统运行期间，用户请求分配的存储量有若干种大小的规格。对此类系统，一般情况下是建立若干个可利用空间表，同一链表中的结点大小相同。每个结点中第一个字设有链域(link)、标志域(tag)和结点类型域(type)
3. 系统运行期间分配给用户的内存块的大小不固定，可以随请求而变。因此，可利用空间表中结点即空闲块的大小也是随意的。通常，操作系统中的可利用空间表属这种类型。由于链表中结点大小不同，则结点的结构与前两种情况也有所不同，结点中除标志域和链域之外，尚需有一个结点大小域(size)，以指示空闲块的存储量。假设某用户需大小为n的内存，而可利用空间表中仅有一块大小为$m ge n$的空间快，则只需将其中大小为n的一部分分配给申请分配的用户，同时将剩余大小为m-n的部分作为一个结点留在链表中即可。然而，若可利用空间表中有若干个不小于n的空闲块时，该分配哪一块呢？通常，可有3种不同的分配策略：
    - 首次拟合法：从表头指针开始查找可利用空间表，将找到的第一个大小不小于n的空闲块的一部分分配给用户
    - 最佳拟合法：将可利用空间表中一个不小于n且最接近n的空闲块的一部分分配给用户，为了节省时间，预先需要排序
    - 最差拟合法：讲可利用空间表中不小于n且是链表中最大的空闲块的一部分分配给用户，为了节省时间，预先需要排序
上述三种分配策略个有所长。一般来说，最佳拟合法适用于请求分配的内存大小范围较广的系统。最差拟合法适用于请求分配大小范围较窄的系统。首次拟合介于二者之间，通常适用于系统事先不掌握运行期间可能出现的请求分配和释放的信息的情况。

从时间上来说，首次拟合 < 最差拟合法 < 最佳拟合法

为了更有效的利用内存，就要求系统在回收时应考虑将地址相邻的空闲块合并成尽可能大的结点。

*边界标识法*





[hsf]: http://imsproduction.oss-cn-shanghai.aliyuncs.com/5608d41af2541dff742f2ee55265ce3b.jpg "这是回溯法解集合幂集的图示"
[hfm]: http://imsproduction.oss-cn-shanghai.aliyuncs.com/5e10fb832932a2b66065fbd85c3e1c12.jpeg "这是赫夫曼编码的图示"
[dag]: http://imsproduction.oss-cn-shanghai.aliyuncs.com/5a1954f7045046091af826e14a090c47.jpeg "这是有向无环图应用示例"